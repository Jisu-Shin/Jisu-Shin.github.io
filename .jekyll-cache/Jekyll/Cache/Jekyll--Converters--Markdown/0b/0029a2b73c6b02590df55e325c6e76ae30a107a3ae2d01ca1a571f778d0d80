I"1<h2 id="cpu-내부-구조에-대해-설명하시오">CPU 내부 구조에 대해 설명하시오</h2>

<p><img src="/images/cpu.jpg" style="width:50%;" /></p>

<ul>
  <li>제어장치 (Control Unit) : 메모리로부터 명령어를 얻어 기계어로 해석한 후 그 의미에 따라 연산장치, 메모리, 입출력장치 등에게 동작을 지시한다</li>
  <li>레지스터: 명령어 주소, 코드, 데이터를 임시로 저장하는 고속의 기억장치</li>
  <li>산술/논리 연산장치(Arithmetic Logic Unit) : 제어 장치로부터 전달받은 명령어를 바탕으로 사칙연산, 논리합, 논리곱 등의 연산을 수행하고 결과 값을 제어 장치에게 전달한다. (ex: LOAD, ADD, STORE) <strong>ALU는 수동적으로 연산처리를 하므로 CU의 명령이 필요하다</strong></li>
</ul>

<hr />

<h2 id="레지스터-종류">레지스터 종류</h2>

<ul>
  <li>특수 레지스터 (SPR)
    <ul>
      <li>Program Counter</li>
      <li>Accumulator</li>
      <li>Instruction Register</li>
      <li>Stackpointer Register</li>
      <li>MAR</li>
      <li>MDR</li>
    </ul>
  </li>
  <li>범용 레지스터 (GPR)</li>
</ul>

<hr />

<h2 id="32비트-cpu와-64비트-cpu">32비트 CPU와 64비트 CPU</h2>

<p>프로그램 실행을 요청받은 CPU가 한번에 처리할 수 있는 메모리의 크기이다</p>

<p>즉, 32비트 CPU는 주어진 데이터를 32비트씩 잘라서 수행하고, 64비트 CPU는 64비트씩 잘라서 수행한다</p>

<p>한번에 수행하는 데이터가 많을수록 데이터 입출력이 줄고 연산이 빨라지기 때문에 64비트 CPU가 훨씬 빠르다</p>

<p>1 words 가 16bit 인가</p>

<p>실제로는 하위  48bit만 사용한다 , 큰 양의 memeory addressing이 필요하지 않기 때문이다</p>

<hr />

<h2 id="gpu란---cpu와-차이">GPU란? - CPU와 차이</h2>

<p>GPU (Graphics Processing Unit), CPU (Central Processing Unit)</p>

<p>CPU,GPU 의 성능지표</p>

<ul>
  <li>클럭(동작속도) 의 수치 =&gt; 높으면 단일 작업을 빠르게 처리하는데 유리</li>
  <li>코어(핵심 회로)의 수 =&gt; 많으면 멀티 태스킹을 하거나 멀티코어 연산에 최적화된 프로그램을 구동하는데 이점</li>
  <li>캐시 메모리(임시 저장소)의 용량 =&gt; 넉넉하면 덩치가 큰 프로그램을 구동하거나 자주하는 작업을 반복처리할 때 작업 효율을 높일 수 있다</li>
</ul>

<p><br /></p>

<p>CPU 는 명령어가 입력된 순서대로 데이터를 처리하는 직렬(순차) 처리 방식에 특화된 구조를 가지고 있다. 내부 면적의 절반 이상이 캐시로 채워져 있기 때문에 GPU에 비해 상대적으로 ALU가 차지하는 공간이 적다. 직렬처리에 최적화된 몇 개의 코어로 구성되어 있다 CPU는 고정소수점 데이터를 많이 사용하는 문서 작성 등 일상 생활의 작업(데이터 처리)을 빠르게 수행할 수 있도록 설계된다</p>

<p>GPU는 비디오, 즉 픽셀로 이루어진 영상을 처리하는 용도로 탄생했다. 이 때문에 GPU 는 여러 명령어를 동시에 처리하는 병렬 처리 방식에 특화된 구조를 가지고 있다. 캐시 메모리 비중이 크지 않고 연산을 할 수 있는 ALU개수가 많다. 병렬처리용으로 설계된 수 천개의 보다 소형이고 효율적인 코어로 구성되어 있다 GPU는 CPU로는 시간이 많이 걸리는 3D 그래픽 작업등을 빠르게 수행하도록 설계된다</p>

<hr />

<h2 id="고정소수점-vs-부동소수점">고정소수점 vs 부동소수점</h2>

<p>고정소수점(fixed point) : 7.625(10) -&gt; 111.101(2)로 변환하는 방법. 부호, 정수부,소수부를 표현하는 비트로 각각 나뉘게 된다. 구현하기 편리하지만 표현할 수 있는 범위가 적다.</p>

<p>부동소수점(floating point) : 소수점이 고정되어 있지 않고 좌우로 움직일 수 있다. 부호, 지수부, 가수부를 표현하는 비트로 나뉘게 된다. 훨씬 더 넓은 범위까지 표현할 수 있지만 오차가 발생한다</p>

<p>CPU 제조사들은 정수나 고정소수점 데이터를 많이 사용하는 인터넷 서핑, 문서 작성 등 일상생활의 작업을 보다 빠르게 수행하도록 설계한다</p>

<p>GPU 제조사들은 CPU로는 시간이 많이 걸리는 부동소수점 실수 연산과 벡터연산을 가지는 멀티미디어, 특히 3차원 그래픽과 사운드를 잘 수행하도록 칩을 만든다.</p>

<hr />

<h2 id="risc와-cisc-차이점">RISC와 CISC 차이점</h2>

<p>프로세서가 가진 명령어 세트를 기준으로 RISC와 CISC로 나눠진다</p>

<ul>
  <li>RISC (Reduce Instruction Set Computer) : 핵심적인 명령어를 기반으로 <strong>최소한의 명렁어 세트를 구성한 프로세서</strong>이다. 고정적인 길이와 간단한 명령어로 빠른 동작 속도를 자랑한다(디코딩이 빠르기 때문) 그래서 여러개의 명령어를 처리할 수 있다 적은 명령어 세트를 가지고 있으므로 프로그램을 구성하는 명령어가 단순하지만 다수의 명령어를 필요로 한다. 명령길이가 고정되어 있기 때문에 코드효율이 낮다</li>
  <li>CISC (Complex Instruction Set COmputer): 연산을 처리하는 <strong>복잡한 명령어들을 수백개 이상 탑재하고 있는 프로세서</strong>이다. 명령어 길이가 다양하며 개수가 많아 (동시에 여러개의 명령처리는 어렵다) 프로그램의 구성이 복잡해지지만(디코딩에 시간이 오래걸린다) 소수의 명령어로 구현할 수 있다. (컴파일러 작성이 쉽다, 호환성이 좋다, 복잡한 명령도 마이크로 코드이므로 실행효율이 좋다)</li>
</ul>

<hr />

<h2 id="레지스터-주소-지정-방식">레지스터 주소 지정 방식</h2>

<p>메모리의 내용이 데이터/주소냐에 따라 Direct/Indirect Addressing으로 구분</p>

<ul>
  <li>
    <p>Direct Addressing : 주소로 찾아가면 바로 데이터를 얻을 수 있다</p>

    <ul>
      <li>장점 : 기억장치 접근이 한번에 이루어진다</li>
      <li>단점 : 오퍼랜드 필드의 길이에 따라 접근할 수 있는 기억장치의 주소공간에 한계가 있다</li>
    </ul>

    <p><br /></p>
  </li>
  <li>
    <p>Indirect Addressing : 주소로 찾아가서 내용을 보니 주소가 있어 그 주소로 가야 적재되어 있는 경우</p>

    <ul>
      <li>장점 : 짧은 길이를 가진 명령어로 큰 용량의 기억 장소의 주소를 지정할 수 있다 ( 직접주소지정의 단점 해결 )</li>
      <li>단점 : 두번의 메모리를 참조해야하므로 처리속도가 제일 느리다</li>
    </ul>
  </li>
  <li>
    <p>간접 접근방법이 성능상으로 떨어지지만 데이터 활용면에서는 유리하다</p>
  </li>
</ul>

<hr />

<h2 id="캐시메모리는-무엇이며-왜-사용하는가">캐시메모리는 무엇이며 왜 사용하는가</h2>

<ul>
  <li>CPU와 주기억장치 사이의 속도차이를 완화하기 위해 사용하는 메모리이다</li>
  <li>캐시 메모리를 사용하면 주기억장치를 접근하는 횟수가 줄어들어 컴퓨터의 처리속도가 향상된다</li>
  <li>당장 필요한 내용을 주기억장치에서 인출하여 캐시 메모리로 옮겨 메모리 접근시간과 CPU의 처리 속도를 맞춘다</li>
  <li>CPU 처리 속도 상승은 곧 성능의 향상이다</li>
  <li>속도: 레지스터 &gt; 캐시메모리</li>
  <li>1차 캐시메모리 (대부분 CPU안쪽에 위치 ) , 2차 캐시메모리 (CPU 바깥쪽에 위치)</li>
  <li>CPU안쪽의 1차 캐시메모리라도 CPU에게 요청하는 시간이 있기 때문에 CPU와 한 몸인 레지스터의 속도가 더 빠름</li>
  <li>캐시를 크게 하면 좋으나 가격이 비싸진다 그래서 병렬 기법(파이프라이닝, 슈퍼스칼라)이 나타났다</li>
  <li>참조 지역성 : 주변의 데이터까지 가져온다
    <ul>
      <li>직접매핑 : hit rate가 낮다</li>
      <li>간접매핑 :</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="파이프라이닝이란">파이프라이닝이란?</h2>

<p><img src="https://t1.daumcdn.net/cfile/tistory/2649453D54B4C5072A" /></p>

<ul>
  <li>단일 사이클의 문제점(클럭 사이클 시간이 너무 길어진다)을 해결하기 위한 방법이다</li>
  <li>하나의 명령어 싸이클을 여러단계로 나누고 각 단계에서 동시에 다른 명령어를 처리하도록 함으로써 CPU속도를 빠르게 하는 기술 ,</li>
  <li>한 동작을 여러 단계로 나누어 동시에 여러 명령어를 실행하여 <strong>처리량(throughput)을 올린다</strong> (처리시간이 빨라지는 것은 아니다)</li>
  <li>슈퍼 파이프라인에 대해 알아보기</li>
</ul>

<hr />

<h2 id="해저드">해저드</h2>

<p>파이프라인으로 발생하는 문제이다</p>

<ol>
  <li>
    <p>구조적 해저드</p>

    <ul>
      <li>다른 단계에 있는 명령어들이 동시에 같은 자원을 사용하려는 상황</li>
      <li>자원을 추가하거나 캐시를 사용해 해결한다</li>
    </ul>
  </li>
  <li>
    <p>데이터 해저드</p>

    <ul>
      <li>수행중인 명령 사이의 종속성</li>
      <li>연산이 끝나기 전에 접근을 할 경우 처리 결과가 맞물린다</li>
      <li>forwarding , instruction 스케쥴링</li>
    </ul>
  </li>
  <li>
    <p>제어 해저드</p>

    <ul>
      <li>
        <p>분기에 의해 발생</p>
      </li>
      <li>
        <p>분기예측으로 해결 -&gt; 예측 못하는 경우 지연 발생</p>
      </li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="슈퍼스칼라란">슈퍼스칼라란?</h2>

<p><img src="https://t1.daumcdn.net/cfile/tistory/233DEB4354B86CD50B" /></p>

<ul>
  <li>한 명령어 사이클 동안 여러 개의 명령어를 동시에 처리할 수 있도록 설계한 CPU 구조</li>
  <li>CPU 내에 여러 개의 파이프 라인을 두어 명령어를 동시에 실행하는 기술</li>
  <li>데이터, 자원, 프로시저 의존성을 가질 때 불가능</li>
  <li>현대 컴퓨터에서 많이 사용함</li>
  <li>파이프라이닝은 단일 코어이지만 슈퍼스칼라는 코어를 여러개로 구성했다</li>
</ul>

<hr />

<h2 id="슈퍼파이프라인">슈퍼파이프라인</h2>

<p>0.5씩 중간에 중첩되게 한다</p>

<hr />

<h2 id="vliw-프로세서">VLIW 프로세서</h2>

<h2 id="컴퓨터-기본-구조에-대해-설명하세요">컴퓨터 기본 구조에 대해 설명하세요</h2>

<p><img src="/images/com_archi.JPG" style="width:70%;" /></p>

<ul>
  <li>
    <p>컴퓨터는 하드웨어와 소프트웨어로 이루어져있습니다 하드웨어의 구성요소는 CPU, 기억장치, 입출력장치가 있으며 각 장치는 시스템버스로 연결되어 있습니다. 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어 나르는 역할을 합니다</p>
  </li>
  <li>
    <p>시스템버스</p>
    <ul>
      <li>데이터 버스 : CPU와 기타 장치에서 데이터를 전달하는 통로입니다. 기억장치와 입출력장치의 명령어와 데이터를 CPU로 보내거나 CPU의 연산 결과를 기억장치와 입출력 장치로 보내므로 양방향 버스입니다</li>
      <li>주소 버스 : 데이터를 실어나르기 위해서는 기억장치의 주소가 필요합니다. CPU가 기억장치나 입출력장치로 기억장치의 주소를 전달하는 통로이기 때문에 단방향 버스입니다</li>
      <li>제어 버스 : 주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요합니다. CPU가 기억장치나 입출력장치에게 제어 신호를 전달하는 통로입니다.  제어 신호에는 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락 , 리셋 등이 있습니다. 제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 양방향 버스입니다</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="메모리의-구조는">메모리의 구조는?</h2>

<p>주기억장치의 용량이 크면 하드디스크에서 데이터를 가져오는 횟수가 줄기 때문에 처리시간이 줄어든다</p>

<hr />

<h2 id="메모리의-계층-구조는-어떻게-되어있는가">메모리의 계층 구조는 어떻게 되어있는가?</h2>

<hr />

:ET